{%- comment -%}
Robust parse-post-authors include (drop-in replacement).

Usage:
  {%- capture p_slugs_csv -%}{% include sections/parse-post-authors.html p_auth=p.authors %}{%- endcapture -%}
  {%- assign p_slugs = p_slugs_csv | split:',' | map:'strip' -%}

Accepts many call shapes; emits CSV of normalized slugs.
{%- endcomment -%}

{%- comment -%} Resolve incoming param names {%- endcomment -%}
{%- assign resolved = nil -%}
{%- if include.p_auth != nil -%}
  {%- assign resolved = include.p_auth -%}
{%- elsif include.p_authors != nil -%}
  {%- assign resolved = include.p_authors -%}
{%- elsif include.authors != nil -%}
  {%- assign resolved = include.authors -%}
{%- elsif include.p != nil -%}
  {%- if include.p.authors != nil -%}
    {%- assign resolved = include.p.authors -%}
  {%- elsif include.p.author != nil -%}
    {%- assign resolved = include.p.author -%}
  {%- elsif include.p.auth != nil -%}
    {%- assign resolved = include.p.auth -%}
  {%- endif -%}
{%- endif -%}
{%- if resolved == nil -%}{%- assign resolved = "" -%}{%- endif -%}

{%- assign p_slugs_raw = "" | split: "|" -%}

{%- comment -%}
Parsing approach:
 1) Use jsonify and look for JSON array markers '[' & ']' → parse CSV from inside.
 2) Else if there's a comma in the string → split on commas.
 3) Else if newlines → split on newlines.
 4) Else if non-empty → treat as a single token (push full string).
{%- endcomment -%}
{%- if resolved != "" -%}
  {%- assign p_json = resolved | jsonify -%}

  {%- if p_json contains '[' and p_json contains ']' -%}
    {%- assign tmp = p_json | remove:'[' | remove:']' | remove:'"' | remove:"'" | strip -%}
    {%- if tmp != "" -%}
      {%- assign p_slugs_raw = tmp | split:',' | map:'strip' -%}
    {%- endif -%}

  {%- elsif p_json contains ',' -%}
    {%- assign tmp = p_json | remove:'"' | remove:"'" | strip -%}
    {%- assign p_slugs_raw = tmp | split:',' | map:'strip' -%}

  {%- elsif p_json contains '\n' -%}
    {%- assign tmp = p_json | remove:'"' | remove:"'" | strip -%}
    {%- assign p_slugs_raw = tmp | split:'\n' | map:'strip' -%}

  {%- else -%}
    {%- assign tmp = p_json | remove:'"' | remove:"'" | strip -%}
    {%- if tmp != "" -%}
      {%- assign p_slugs_raw = p_slugs_raw | push: tmp -%}
    {%- endif -%}
  {%- endif -%}
{%- endif -%}

{%- comment -%}
Fallback: if parsing produced nothing but we have a raw string, try matching known author slugs
embedded in the string (handles concatenated slugs like "michael-basilkyle-ingersoll").
{%- endcomment -%}
{%- assign fallback_candidates = "" | split: "|" -%}
{%- if p_slugs_raw == "" or p_slugs_raw.size == 0 -%}
  {%- if resolved != "" -%}
    {%- assign resolved_str = resolved | jsonify | remove:'"' | remove:"'" | strip -%}
    {%- for a in site.authors -%}
      {%- assign candidate_slug = a.slug | slugify -%}
      {%- if candidate_slug != "" and resolved_str contains candidate_slug -%}
        {%- assign fallback_candidates = fallback_candidates | push: candidate_slug -%}
      {%- endif -%}
    {%- endfor -%}
    {%- if fallback_candidates != "" and fallback_candidates.size > 0 -%}
      {%- assign p_slugs_raw = fallback_candidates -%}
    {%- endif -%}
  {%- endif -%}
{%- endif -%}

{%- comment -%} Normalize and emit CSV {%- endcomment -%}
{%- assign first_out = true -%}
{%- for ps in p_slugs_raw -%}
  {%- assign ps_norm = ps | split:'.' | first | slugify | strip -%}
  {%- if ps_norm != "" -%}
    {%- if first_out -%}
{{ ps_norm }}{%- assign first_out = false -%}
    {%- else -%}
,{{ ps_norm }}{%- endif -%}
  {%- endif -%}
{%- endfor -%}
